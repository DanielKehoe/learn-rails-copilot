Layout and Views
================

In previous chapters we created a dynamic home page and learned
techniques for troubleshooting.

In this chapter we'll look closely at view files, particularly the
application layout, so we can organize the design of our web pages.
We'll also learn how to add a CSS stylesheet to improve the graphic
design of our web pages.

This chapter covers a lot of ground, so take a break before jumping in,
or pace yourself to absorb it all.

Template Languages
------------------

HTML is intended for markup, which means applying formatting to a text
file. For a web application, ordinary HTML is not sufficient; we need to
mix in Ruby code. We'll use a *templating language* that gives us a
syntax for mixing HTML tags and Ruby code. The Ruby code will be
processed by a *templating engine* built into Rails. The output will be
pure HTML sent to the browser.

The most popular templating language available for Rails is *ERB*,
Embedded Ruby, which is the Rails default.

In the "Concepts" chapter in Book One, you learned that components of Rails can be
mixed for different "stacks." Some developers substitute
[Haml](http://haml.info/) or [Slim](http://slim-lang.com/) for ERB.
We'll use ERB in this book because it is the most popular.

Introducing the Application Layout
----------------------------------

We've already created the view file for our home page.

The file **app/views/visitors/new.html.erb** looks like this:


```erb
<h3>Home</h3>
<p>Welcome to the home of <%= @owner.name %>.</p>
<p>I was born on <%= @owner.birthdate %>.</p>
<p>Only <%= @owner.countdown %> days until my birthday!</p>
```

The first line in the file contains an HTML heading tag, `<h3>`, with
headline text, "Home."

When you used the browser Developer Tools view to see the HTML file received
by the server, you saw this:


```html
<!DOCTYPE html>
<html>
<head>
<title>LearnRails</title>
<meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="..." />
<link rel="stylesheet" media="all" href="/assets/application.css?body=1" data-turbolinks-track="reload" />
<script src="/assets/jquery.js?body=1" data-turbolinks-track="reload"></script>
<script src="/assets/jquery_ujs.js?body=1" data-turbolinks-track="reload"></script>
<script src="/assets/turbolinks.js?body=1" data-turbolinks-track="reload"></script>
<script src="/assets/action_cable.js?body=1" data-turbolinks-track="reload"></script>
<script src="/assets/cable.js?body=1" data-turbolinks-track="reload"></script>
<script src="/assets/application.js?body=1" data-turbolinks-track="reload"></script>
</head>
<body>

<h3>Home</h3>
<p>Welcome to the home of Foobar Kadigan.</p>
<p>I was born on 1990-09-22.</p>
<p>Only 126 days until my birthday!</p>


</body>
</html>
```

If you've built websites before, you'll recognize the HTML file conforms
to the HTML5 specification, with a `DOCTYPE`, `<head>` and `<body>`
tags, and miscellaneous tags in the HEAD section, including a title and
various CSS and JavaScript assets.

If you look closely, you'll see some HTML attributes you might not
recognize, for example the `data-turbolinks-track` attribute. That is
added by Rails to support
[turbolinks](https://github.com/turbolinks/turbolinks), for faster loading of
webpages.

For the most part, everything is ordinary HTML. But only part of it
originates from the view file we've created for our home page.

Where did all the extra HTML come from?
---------------------------------------

The final HTML file is more than twice the size of the view file.

The additional tags come from the default *application layout* file.

Rails has combined the Visitors#New view with the default application
layout file. To be precise, the `new` method in the Visitors controller
creates the home page by combining two files:

* the application layout file **app/views/layouts/application.html.erb**
* the Visitors#New template in the file **app/views/visitors/new.html.erb**

We say Rails "renders" (or "delivers") a new view by combining two files.

Let's examine the application layout file.

Open the file **app/views/layouts/application.html.erb**:


```erb
<!DOCTYPE html>
<html>
  <head>
    <title>LearnRails</title>
    <%= csrf_meta_tags %>

    <%= stylesheet_link_tag 'application', media: 'all',
        'data-turbolinks-track': 'reload' %>
    <%= javascript_include_tag 'application',
        'data-turbolinks-track': 'reload' %>
  </head>

  <body>
    <%= yield %>
  </body>
</html>
```

Static pages delivered from the **public** folder do not use the default
application layout. But every page generated by the
model-view-controller architecture in the **app/** folder incorporates
the default application layout, unless you specify otherwise.

The default application layout is where you put HTML that you want to
include on every page of your website.

Remember when we looked at the hidden code in the controller that
renders a view? The controller uses the `render` method to combine the
view file with the application layout.

Here's the Visitors controller, again, with the hidden `render` method revealed:


```ruby
class VisitorsController < ApplicationController

  def new
    @owner = Owner.new
    render 'visitors/new'
  end

end
```

The `render` method combines the **app/views/visitors/new.html.erb**
view file with the **app/views/layouts/application.html.erb**
application layout.

Alternatively, you could tell the controller to render the view without
any application layout:


```ruby
    render 'visitors/new', :layout => false
```

Or you could specify an alternative layout file, for example
**app/views/layouts/special.html.erb**:


```ruby
    render 'visitors/new', :layout => 'special'
```

An alternative layout can be useful for special categories of pages,
such as administrative pages or landing pages.

We won't use alternative layouts in this tutorial application, but it's
good to know they are an option. The reference [RailsGuides: Layouts and
Rendering in
Rails](http://guides.rubyonrails.org/layouts_and_rendering.html)
explains more about using alternative layouts.

Yield
-----

How does the `render` method insert the view file in the application
layout? How do the two files get combined?

Notice that the default application layout contains the Ruby keyword
`yield`.


```erb
.
.
.
<%= yield %>
.
.
.
```

The `yield` keyword is replaced with a view file that is specific to the
controller and action, in this case, the
**app/views/visitors/new.html.erb** view file.

The content from the view is inserted where you place the `yield`
keyword. The `yield` keyword pulls in another view file.

Yield Variations
----------------

We won't do it, but you could also use the `yield` keyword to insert a
sidebar or a footer.

Rails provides ways to insert content into a layout file at different
places. The `content_for` method is helpful when your layout contains
distinct regions such as sidebars and footers that should contain their
own blocks of content.

For example, you could create an application layout that includes a
sidebar. This is just an example, so don't add it to the application you
are building:


```erb
<!DOCTYPE html>
<html>
<head>
  <title>LearnRails</title>
  <%= csrf_meta_tags %>
  <%= stylesheet_link_tag 'application', media: 'all',
      'data-turbolinks-track': 'reload' %>
  <%= javascript_include_tag 'application',
      'data-turbolinks-track': 'reload' %>
</head>
<body>
  <div class="main">
    <%= yield %>
  </div>
  <div class="sidebar">
    <%= yield :sidebar %>
  </div>
</body>
</html>
```

This view file provides both the main content and a sidebar:


```erb
<% content_for :sidebar do %>
  <h3>Contact Info</h3>
  <p>Email: me@example.com</p>
<% end %>
<h3>Main</h3>
<p>Welcome!</p>
```

This section gets inserted at the `<%= yield :sidebar %>` location:


```erb
<% content_for :sidebar do %>
  <h3>Contact Info</h3>
  <p>Email: me@example.com</p>
<% end %>
.
.
.
```

The rest of the file gets inserted at the main `<%= yield %>` location.

Again, don't add this to your application. I'm just offering it as an
example of multiple `yield` statements.

The reference [RailsGuides: Layouts and Rendering in
Rails](http://guides.rubyonrails.org/layouts_and_rendering.html)
explains more about using `yield` and `content_for`.

ERB Delimiters
--------------

Earlier, we saw ERB `<%= ... %>` delimiters allow us to insert Ruby
expressions which are replaced by the result of evaluating the code.
Here is an example that displays the number [4]()


```erb
<%= 2 + 2 %>
```

Look closely and you'll see this ERB delimiter is slightly different:


```erb
<% 3.times do %>
  <li>list item</li>
<% end %>
```

An ERB delimiter that does not contain the `=` (equals) sign
will execute Ruby code but will not display the result. It is commonly
used to add Ruby blocks to HTML code, so you'll often see `do` and `end`
statements within ERB `<% ... %>` delimiters. The example above will
create three list items, like this:


```html
<li>list item</li>
<li>list item</li>
<li>list item</li>
```

A third version of the ERB delimiter syntax is rarely seen:


```erb
<%# this is a comment %>
```

It is only used for adding comments. The expression within the ERB
`<%# ... %>` delimiters will not execute and will not appear when the
page is output as HTML.

Introducing View Helpers
------------------------

We can use ERB delimiters to create Rails *view helpers*.

We've seen how ERB delimiters can enclose Ruby code.

In the application layout file, the `<%= ... %>` delimiters don't
include anything that looks like Ruby code. For example, we see
`<%= csrf_meta_tags %>` which seems to be neither HTML nor anything from
the Ruby API. In fact, this expression is Ruby code, but it is from the
Rails API and only found in Rails applications.

Ruby is an ideal choice for a web application development platform such
as Rails because it can easily be used to create a *domain-specific
language* (or <em>DSL</em>). Much of Rails is a domain-specific
language. The Smalltalk programming language was famous for its slogan
"Code should read like a conversation." Ruby, which borrows much from
Smalltalk, makes it easy to add new words to the conversation. We can
add new keywords that produce complex behaviour, creating entire new
APIs such as Rails. Ruby makes it easy for the Rails core team to add
keywords such as `csrf_meta_tags` that are additions to the Ruby
language.

In this case, Ruby's ability to produce a domain-specific language gives
us Rails *view helpers*.

Think of Rails view helpers as "macros to generate HTML." You may have
used macros to automate a series of commands in World of Warcraft or
other games. If you're an office worker, you may have used macros in
Microsoft Word or Excel. A Rails view helper is a keyword that expands
into a longer string of HTML tags and content.

In this case, the `csrf_meta_tags` view helper expands into two lines of
HTML:


```html
<meta name="csrf-param" content="authenticity_token" />
<meta name="csrf-token" content="bhd8ZZJ7dsMza8ZT1Csm5IuCIxkNNq==" />
```

Why do we need this cryptic code? It turns out that almost any website
that accepts user input via a form is vulnerable to a security bug (an
<em>exploit</em>) named a [cross-site request
forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery). To
prevent rampant CSRF exploits, the Rails core team includes the
`csrf_meta_tags` view helper in the default application layout. Rails
provides a number of similar features that make websites more secure.

A Rails view file becomes much less mysterious when you realize that
many of the keywords you see are view helpers. Strange new keywords may
be part of the Rails API. Or they may be provided by gems you've added
(gem developers often use the Ruby DSL capability to create new
keywords). Think of it this way: Ruby gives developers the power to
create an unlimited number of new "HTML tags." These tags are not really
HTML because they are not part of the HTML specification. But they serve
as shortcuts to produce complex snippets of HTML and content.

Now that we've learned about view helpers, we can start building our
default application layout.

The Rails Layout Gem
--------------------

Every Rails application needs a well-designed application layout. The
Rails default starter application, which we get when we run `rails new`,
provides a barebones application layout. It is purposefully simple so
developers can add the code they need to accommodate any front-end
framework (we'll look closely at front-end frameworks in the next
chapter).

In this chapter we'll start with a simple application layout file,
adding a little CSS for simple styling. In the next chapter, we'll
upgrade the application layout file to use the Bootstrap front-end
framework.

To make it easy, we'll use the
[rails_layout](https://github.com/RailsApps/rails_layout) gem to
generate files for an application layout. In this chapter, we'll use the
rails_layout gem to create our basic layout and CSS files. In the next
chapter, we'll use the rails_layout gem to create layout files for Bootstrap.

In your **Gemfile**, you've already added:


```ruby
gem 'rails_layout'
```

and previously run `$ bundle install`.

Rails provides the `rails generate` command to run simple scripts that
are packaged into gems.

The rails_layout gem uses the `rails generate` command to set up files
we need. Run:


```console
$ rails generate layout:install simple --force
```

The `--force` argument will force the gem to replace the existing
**app/views/layouts/application.html.erb** file.

If you have the **app/views/layouts/application.html.erb** file open in
your text editor, it will change.

The rails_layout gem will rename the file:

-   **app/assets/stylesheets/application.css**

to:

-   **app/assets/stylesheets/application.css.scss**

The gem will add (or modify) five files:

-   **app/views/layouts/application.html.erb**
-   **app/assets/stylesheets/simple.css**
-   **app/views/layouts/_messages.html.erb**
-   **app/views/layouts/_navigation.html.erb**
-   **app/views/layouts/_navigation_links.html.erb**

Examining these files closely will reveal a great deal about the power
of Rails. We'll dedicate the rest of this chapter to exploring the
contents of these files.

Basic Boilerplate
-----------------

Open the file **app/views/layouts/application.html.erb**:


```erb
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= content_for?(:title) ? yield(:title) : "Learn Rails" %></title>
    <meta name="description" content=
      "<%= content_for?(:description) ? yield(:description) : "Learn Rails" %>">
    <%= stylesheet_link_tag 'application', media: 'all',
      'data-turbolinks-track' => 'reload' %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track' => 'reload' %>
    <%= csrf_meta_tags %>
  </head>
  <body>
    <header>
      <%= render 'layouts/navigation' %>
    </header>
    <main role="main">
      <%= render 'layouts/messages' %>
      <%= yield %>
    </main>
  </body>
</html>
```

Some of this code is already familiar.

You'll recognize the standard HTML `DOCTYPE`, `<head>`, and `<body>`
tags.

We've already discussed the `yield` keyword.

We've seen the `<%= ... %>` delimiters surrounding the `csrf_meta_tags`
view helper:

-   `csrf_meta_tags` - generates `<meta>` tags that prevent [cross-site
request forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery)

The rest of the file may be unfamiliar. We'll examine it line by line.

Adding Boilerplate
------------------

Webmasters who build static websites are accustomed to setting up web
pages with "boilerplate," or basic templates for a standard web page.
The well-known [HTML5 Boilerplate](http://html5boilerplate.com/) project
has been recommending "best practice" tweaks to web pages since 2010.
Very few of the HTML5 Boilerplate recommendations are relevant for Rails
developers, as Rails already provides almost everything required. We'll
discuss one important boilerplate item and a few "nice to have" extras.

If you want to learn more, the article [HTML5 Boilerplate for Rails
Developers](http://railsapps.github.io/rails-html5-boilerplate.html)
looks at the recommendations.

### Viewport

The `viewport` metatag improves the presentation of web pages on mobile
devices. Setting a viewport tells the browser how content should fit on
the device's screen. The tag is required for either Bootstrap or Zurb
Foundation front-end frameworks.

The `viewport` metatag looks like this:


```erb
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

Apple's developer documentation on [Configuring the
Viewport](http://developer.apple.com/library/safari/#documentation/AppleApplications/Reference/SafariWebContent/UsingtheViewport/UsingtheViewport.html)
provides details.

### Title and Description

If you want to maximize traffic to your website, you should make your
web pages search-engine friendly. That means adding *title* and
*description* metatags. Google uses contents of the title tag to display
titles in search results. And it will sometimes use the content of a
description metatag in search results snippets. See Google's explanation
of how it uses [Site Title and
Description](http://support.google.com/webmasters/bin/answer.py?hl=en&answer=35624).
Good titles and descriptions improve clickthrough from Google searches.

Title and description looks like this:


```erb
<title><%= content_for?(:title) ? yield(:title) : "Learn Rails" %></title>
<meta name="description" content="<%= content_for?(:description) ?
    yield(:description) : "Learn Rails" %>">
```

The rails_layout gem has created a default title and description based
on our project name.

Later in the tutorial, we'll see how to use a `content_for` statement to
set a title and description for each individual page.

The code is complex if you haven't seen advanced Ruby before. It uses
the Ruby [ternary
operator](http://ruby.about.com/od/beginningruby/a/The-Ternary-Or-Conditional-Operator.htm)
which maximizes compactness at the price of introducing obscurity.
You'll recall from the "Just Enough Ruby" chapter that it is a fancy
conditional statement that says, "if `content_for?(:title)` is present
in the view file, use `yield(:title)` to include it, otherwise just
display 'Learn Rails'."

Asset Pipeline
--------------

You may have noticed these Rails helper methods:

-   `stylesheet_link_tag`
-   `javascript_include_tag`

These are tags that add CSS and JavaScript to the web page using the
Rails *asset pipeline*.

The Rails *asset pipeline* utility is one of the most powerful features
of the platform. It offers convenience to the developer and helps
organize an application; more importantly, it improves the speed and
responsiveness of any complex website. If you're going to do any
front-end development with CSS or JavaScript in Rails, you must
understand the Rails asset pipeline. Here's how it works.

### Assets Without Rails

When building non-Rails websites, webmasters add JavaScript to a page
using the `<script>` tag. For every JavaScript file, they add an
additional `<script>` tag, so a page HEAD section looks like this:


```html
<!DOCTYPE html>
<html>
<head>
  <title>Page that uses multiple JavaScript files</title>
  <script src="jquery.js" type="text/javascript"></script>
  <script src="jquery.plugin.js" type="text/javascript"></script>
  <script src="custom.js" type="text/javascript"></script>
</head>
```

The same is true for CSS files in non-Rails websites. You add a `<link>`
tag for each stylesheet file. With multiple stylesheets, the HEAD
section of your application layout might look like this:


```html
<!DOCTYPE html>
<html>
<head>
  <title>Page that uses multiple CSS files</title>
  <link href="core.css" rel="stylesheet" type="text/css" />
  <link href="site.css" rel="stylesheet" type="text/css" />
  <link href="custom.css" rel="stylesheet" type="text/css" />
</head>
```

If you want to handle CSS and JavaScript without Rails, you can place
your files in the **public** folder. If you do so, every time you add a
JavaScript or CSS file, you must modify the application layout file.
Instead, use the asset pipeline and simplify this.

### Assets With Rails

The asset pipeline consists of two folders:

-   **app/assets/javascripts/**
-   **app/assets/stylesheets/**

Any JavaScript and CSS file you add to these folders is automatically
added to every page.

In development, when the web browser makes a page request, the files in
the asset pipeline folders are combined together and concatenated as
single large files, one for JavaScript and one for CSS.

If you examine the application layout file, you'll see the tags that
perform this service:


```erb
<%= stylesheet_link_tag 'application', media: 'all',
    'data-turbolinks-track' => 'reload' %>
<%= javascript_include_tag 'application', 'data-turbolinks-track' => 'reload' %>
```

The HTML delivered to the browser looks like this:


```html
<link href="/assets/application.css" media="all" rel="stylesheet" type="text/css" />
<script src="/assets/application.js" type="text/javascript"></script>
```

Using the asset pipeline, there is no need to modify the application
layout file each time you create a new JavaScript or CSS file. Create as
many files as you need to organize your JavaScript or CSS code and, in
production, you'll automatically get one single file delivered to the
browser. In development mode, Rails continues to deliver multiple files
for easier debugging.

In production, there's a big performance advantage with the asset
pipeline. Requesting files from the server is a time-consuming operation
for a web browser, so every extra file request slows down the browser.
The Rails asset pipeline eliminates the performance penalty of multiple
`<script>` or `<link>` tags. The Rails asset pipeline also compresses
JavaScript and CSS files for faster page loads.

The asset pipeline is an example of a Rails convention that helps
developers build complex websites. It is not needed for a simple website
that uses a few JavaScript or CSS files. But it is beneficial on bigger
projects.

The asset pipeline has limitations, especially for projects with complex
front-end JavaScript. Rails developers who integrate JavaScript front-end
frameworks such as React or Angular often choose not to use the asset pipeline.
Instead they rely on JavaScript tooling such as [Webpack](https://webpack.github.io/)
to manage complex JavaScript assets.

Now that you understand the purpose of the Rails asset pipeline, let's
look at more of the code in the default application layout file.

Navigation Links
----------------

Every website needs navigation links.

You can add navigation links directly to your application layout but
many Rails developers prefer to create a [partial template](http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials)
––a "partial"––to better organize the default application layout.

### Introducing Partials

A *partial* is similar to any view file, except the filename begins with
an underscore character. Place the file in any view folder and you can
use the `render` keyword to insert the partial.

We're not going to add a footer to our tutorial application, but here is
how we could do it. We'd use the `render` keyword with a file named
**app/views/layouts/_footer.html.erb**:


```erb
<%= render 'layouts/footer' %>
```

Notice that you specify the folder within the **app/views/** directory
with a truncated version of the filename. The `render` method doesn't
want the `_` underscore character or the `.html.erb` file extension.
That can be confusing; it makes sense when you remember that Rails likes
"convention over configuration" and economizes on extra characters when
possible.

We're not going to add a footer to our application, but we will add
navigation links by using a partial. First, let's learn about *link
helpers*.

### Introducing Link Helpers

There's no rule against using raw HTML in our view files, so we could
create a partial for navigation links that uses the HTML `<a>` anchor
tag like this:


```erb
<ul class="nav">
  <li><a href="/">Home</a></li>
  <li><a href="/about">About</a></li>
  <li><a href="/contact">Contact</a></li>
</ul>
```

Rails gives us another option, however. We can use the Rails `link_to`
view helper instead of the HTML `<a>` anchor tag. The Rails `link_to`
helper eliminates the crufty `<>` angle brackets and the unnecessary
`href=""`. More importantly, it adds a layer of abstraction, using the
routing configuration file to form links. This is advantageous if we
make changes to the location of the link destinations. Earlier, when we
created a static "About" page, we first set the **config/routes.rb**
file with a route to the "About" page:
`root to: redirect('/about.html')`. Later we removed the static "About"
page and set the **config/routes.rb** file with a route to the dynamic
home page: `root to: 'visitors#new'`. If we used the raw HTML `<a>`
anchor tag, we'd have to change the raw HTML everywhere we had a link to
the home page. Using the Rails `link_to` helper, we name a route and
make any changes once, in the **config/routes.rb** file.

When you use the Rails `link_to` helper, you'll avoid the problem of
link maintenance that webmasters face on static websites. Some
webmasters like to use *absolute* URLs, specifying a host name in the
link, for example `http://www.example.com/about.html`. Absolute URLs are
a headache when moving the site, for example from `staging.example.com`
to `www.example.com`. The problem is avoided by using *relative* URLs,
such as `/about.html`, `about.html`, or even `../about.html`. But
relative URLs are fragile, and moving files or directories often results
in overlooked and broken links. Instead, with the Rails `link_to`
helper, you always get the destination location specified in the
**config/routes.rb** file.

### Navigation Partial

Examine the **app/views/layouts/application.html.erb** and you'll see
the use of the navigation partial.

We include the navigation partial in our application layout with the
expression:


```erb
.
.
.
<%= render 'layouts/navigation' %>
.
.
.
```

Open the file **app/views/layouts/_navigation.html.erb**:


```erb
<ul class="nav">
  <li><%= link_to 'Home', root_path %></li>
  <%= render 'layouts/navigation_links' %>
</ul>
```

You'll see the `link_to` helper.

Here the `link_to` helper takes two parameters. The first parameter is
the string displayed as the anchor text (`'Home'`). The second parameter
is the route. In this case, the route `root_path` has been set in the
**config/routes.rb** file.

The navigation partial includes another partial, which we'll call the
navigation links partial:


```erb
.
.
.
  <%= render 'layouts/navigation_links' %>
.
.
.
```

This demonstrates that one partial can include another partial, so that
partials can be "nested."

### Navigation Links Partial

In our simple application, there's no obvious reason to nest another
partial. But we'll see in the next chapter that it is convenient,
because we can isolate the complex markup required by Bootstrap
from the simple list of links we need for navigation.

Open the file **app/views/layouts/_navigation_links.html.erb**:


```erb
<%# add navigation links to this file %>
```

As we add pages to our application, we'll add links to this file.

For now, we have nothing to add.

Flash Messages
--------------

Rails provides a standard convention to display alerts (including error
messages) and other notices (including success messages), called a
<em>flash message</em>. The name comes from the term "flash memory" and
should not be confused with the "Adobe Flash" web development platform
that was once popular for animated websites. The flash message is
documented in the [RailsGuides: Action Controller
Overview](http://guides.rubyonrails.org/action_controller_overview.html#the-flash).

Here's a flash message you might see after logging in to an application:

![Flash message in Rails.\label{fig:flash-message}](images/figures/learn-rails-44-flash.png)

It is called a "flash message" because it appears on a page temporarily.
When the page is reloaded or another page is visited, the message
disappears.

Typically, you will see only one flash message on a page. But there is
no limit to the number of flash messages that can appear on a page.

### Creating Flash Messages

Flash messages are created in a controller. For example, we can add
messages to the home page by modifying the file
**app/controllers/visitors_controller.rb** like this:


```ruby
class VisitorsController < ApplicationController

  def new
    @owner = Owner.new
    flash[:notice] = 'Welcome!'
    flash[:alert] = 'My birthday is soon.'
  end

end
```

If you test the application after adding the messages to the
VisitorsController, you'll see two flash messages appear on the page.

Rails provides the `flash` object so that messages can be created in the
controller and displayed on the rendered web page.

In this example, we create a flash message by associating the object
`flash[:notice]` with the string `'Welcome!'`. We can assign other
messages, such as `flash[:alert]` or even `flash[:warning]`. In
practice, Rails uses only `:notice` and `:alert` as flash message keys
so it is wise to stick with just these.

### Flash and Flash Now

You can control the persistence of the flash message by choosing from
two variants of the `flash` directive.

Use `flash.now` in the controller when you immediately render a page,
for example with a `render :new` directive. With `flash.now`, the
message will vanish after the user clicks any links.

Use the simple variant, `flash`, in the controller when you redirect to
another page, for example with a `redirect_to root_path` directive. If
you use `flash.now` before a redirect, the user will not see the flash
message because `flash.now` does not persist through redirects or links.
If you use the simple `flash` directive before a `render` directive, the
message will appear on the rendered page and reappear on a subsequent
page after the user clicks a link.

In our example above, we really need to use the `flash.now` variant
because the controller provides a hidden `render` method. Update the
file **app/controllers/visitors_controller.rb**:


```ruby
class VisitorsController < ApplicationController

  def new
    @owner = Owner.new
    flash.now[:notice] = 'Welcome!'
    flash.now[:alert] = 'My birthday is soon.'
  end

end
```

Using `flash.now` will make sure the message only appears on the
rendered page and will not persist after a user follows a link to a new
page.

If you ever see a "sticky" flash message that won't go away, you need to
use `flash.now` instead of `flash`.

### Explaining the Ruby Code

If you're new to programming in Ruby, it may be helpful to learn how the
`flash` object works.

The `flash` object is a Ruby *hash*.

You'll recall from the "Just Enough Ruby" chapter that a hash is a data
structure that associates a key to some value. You retrieve the value
based upon its key. This construct is called a *dictionary* in other
languages, which is appropriate because you use the key to "look up" a
value, as you would look up a definition for a word in a dictionary.

Hash is a type of *collection*. Presumably, the Rails core contributors
who implemented the code chose to use a collection so that a page could
be given multiple flash messages. Because we have a collection with
(possibly) multiple messages, we need to retrieve each message one at a
time.

We learned earlier that all collections support an *iterator* method
named `each`. Iterators return all the elements of a collection, one
after the other. The iterator returns each key-value pair, item by item,
to a *block*. In Ruby, a block is delimited by `do` and `end` or `{ }`
braces. You can add any code to a block to process each item from the
collection.

Here is simple Ruby code to iterate through a `flash` object, outputting
each flash message in an HTML `div` tag and applying a CSS class for
styling:


```ruby
flash.each do |key, value|
  puts '' + value + ''
end
```

In this simple example, we use `each` to iterate through the flash hash,
retrieving a `key` and `value` that are passed to a block to be output
as a string. We've chosen the variable names `key` and `value` but the
names are arbitrary. In the next example, we'll use `name` and `msg` as
variables for the key-value pair. The output string will appear as HTML
like this:


```erb
<div class="notice">Welcome!</div>
<div class="alert">My birthday is soon.</div>
```

Let's continue examining our layout files.

### The Flash Messages Partial

Flash messages are a very useful feature for a dynamic website.

Code to display flash messages can go directly in your application
layout file or you can use a partial.

Examine the file **app/views/layouts/_messages.html.erb**:


```erb
<% flash.each do |name, msg| %>
  <% if msg.is_a?(String) %>
    <%= content_tag :div, msg, :class => "flash_#{name}" %>
  <% end %>
<% end %>
```

It improves on our simple Ruby example in several ways. First, the
expression `if msg.is_a?(String)` serves as a test to make sure we only
display messages that are strings. Second, we use the Rails
`content_tag` view helper to create the HTML `div`. The `content_tag`
helper eliminates the messy soup of angle brackets and quote marks we
used to create the HTML output in the example above. Finally, we apply a
CSS `class` and combine the word "flash" with "notice" or "alert" to
make the CSS class.

We include the flash messages partial in our application layout with the
expression:


```erb
.
.
.
<%= render 'layouts/messages' %>
.
.
.
```

HTML5 Elements
--------------

Let's look again at the **app/views/layouts/application.html.erb** file.

To complete our examination of the application layout file, we'll look
at a few structural elements. These elements are not unique to a Rails
application and will be familiar to anyone who has done front-end
development.

Notice the tags that are structural elements in the HTML5 specification:

-   `<header>`
-   `<main>`

These elements add structure to a web page. The tags don't add any new
behavior but make it easier to determine the structure of the page and
apply CSS styles.

We wrap the navigation partial in the `<header>` tag:


```erb
<header>
  <%= render 'layouts/navigation' %>
</header>
```

The `<header>` tag is typically used for branding or navigation.

Notice the *main tag*:


```erb
<main role="main">
  <%= render 'layouts/messages' %>
  <%= yield %>
</main>
```

We wrap our messages partial and `yield` expression in a
`<main role="main">` element. The `<main>` tag is among the newest HTML5
elements (see the [W3C
specification](http://www.w3.org/html/wg/drafts/html/master/grouping-content.html#the-main-element)
for details). From the specification: "The main content area of a
document includes content that is unique to that document and excludes
content that is repeated across a set of documents such as site
navigation links, copyright information, site logos." We follow the
advice of the specification and wrap our unique content in the `<main>`
tag.

The specification recommends, "Authors are advised to use ARIA
role='main' attribute on the main element until user agents implement
the required role mapping." [ARIA](http://www.w3.org/WAI/intro/aria),
the Accessible Rich Internet Applications Suite, is a specification to
make web applications more accessible to people with disabilities. That
means the `role="main"` attribute is there for any web browsers that
don't yet recognize the `<main>` tag, and may help people with
disabilities.

We could add a `<footer>` tag. It typically contains links to copyright
information, legal disclaimers, or contact information. We don't have a
footer in our tutorial application but you can add the `<footer>` tag,
with additional content, if you want.

Application Layout
------------------

Our application layout is complete. We don't have to add anything
because the rails_layout gem has created everything we need.


```erb
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= content_for?(:title) ? yield(:title) : "Learn Rails" %></title>
    <meta name="description" content=
      "<%= content_for?(:description) ? yield(:description) : "Learn Rails" %>">
    <%= stylesheet_link_tag 'application', media: 'all',
      'data-turbolinks-track' => 'reload' %>
    <%= javascript_include_tag 'application', 'data-turbolinks-track' => 'reload' %>
    <%= csrf_meta_tags %>
  </head>
  <body>
    <header>
      <%= render 'layouts/navigation' %>
    </header>
    <main role="main">
      <%= render 'layouts/messages' %>
      <%= yield %>
    </main>
  </body>
</html>
```

We have the `viewport` metatag, a title, and a description.

We have partials for navigation links and flash messages.

Finally we have HTML5 structural elements.

That's all we need for now. In the next chapter, we'll revise it to
support styling with Bootstrap.

Simple CSS
----------

So far, we've examined four files that were added by the rails_layout
gem:

-   **app/views/layouts/application.html.erb**
-   **app/views/layouts/_messages.html.erb**
-   **app/views/layouts/_navigation.html.erb**
-   **app/views/layouts/_navigation_links.html.erb**

Let's examine the CSS file that was created by the rails_layout gem.

Open the file **app/assets/stylesheets/simple.css**:


```css
/*
 * Simple CSS stylesheet for a navigation bar and flash messages.
 */
main {
  background-color: #eee;
  padding-bottom: 80px;
  width: 100%;
  }
header {
  border: 1px solid #d4d4d4;
  background-image: linear-gradient(to bottom, white, #f2f2f2);
  background-color: #f9f9f9;
  -webkit-box-shadow: 0 1px 10px rgba(0, 0, 0, 0.1);
  -moz-box-shadow: 0 1px 10px rgba(0, 0, 0, 0.1);
  box-shadow: 0 1px 10px rgba(0, 0, 0, 0.1);
  margin-bottom: 20px;
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
}
ul.nav li {
  display: inline;
}
ul.nav li a {
  padding: 10px 15px 10px;
  color: #777777;
  text-decoration: none;
  text-shadow: 0 1px 0 white;
}
.flash_notice, .flash_alert {
  padding: 8px 35px 8px 14px;
  margin-bottom: 20px;
  text-shadow: 0 1px 0 rgba(255, 255, 255, 0.5);
  border: 1px solid #fbeed5;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  border-radius: 4px;
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-size: 14px;
  line-height: 20px;
}
.flash_notice {
  background-color: #dff0d8;
  border-color: #d6e9c6;
  color: #468847;
}
.flash_alert {
  background-color: #f2dede;
  border-color: #eed3d7;
  color: #b94a48;
}
```

If you already know CSS, you'll see we've set a background color for the
`main` section of the page. We've also set styles for a header,
navigation links, and flash messages. This book is about Rails, not CSS,
so we won't examine this closely. For more on CSS, there are thousands
of tutorials on the web, but I like these:

-   [Codeacademy](http://www.codecademy.com/courses/web-beginner-en-TlhFi/0/1?curriculum_id=50579fb998b470000202dc8b)
-   [HTML Dog](http://htmldog.com/guides/css/beginner/)

Remember what we learned about the Rails asset pipeline. By default, any
CSS file in the **app/assets/stylesheets/** folder will be added
automatically to the **application.css** file that is included in the
default application layout.

In the next chapter, we remove the **app/assets/stylesheets/simple.css**
and use Bootstrap to supply styles for the header, navigation
links, and flash messages. For now, the **simple.css** file adds some
basic styling and layout to the application.

Test the Application
--------------------

Let's run the application to see how it looks with the new application
layout. The web server may already be running. If not, enter the
command:


```console
$ rails server
```

Open a web browser window and navigate to
[http://localhost:3000/](http://localhost:3000).

If you experimented with adding flash messages "Welcome" and "My
birthday is soon," you'll see the messages when you visit the home page.

Our home page now has only one navigation link, for "Home." We'll add
links for "About" and "Contact" pages soon.

Git
---

Let's commit our changes to the Git repository and push to GitHub:


```console
$ git add -A
$ git commit -m "update application layout"
$ git push
```


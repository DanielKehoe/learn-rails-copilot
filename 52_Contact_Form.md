Contact Form
============

Forms are ubiquitous on the web, to the degree we seldom notice how
often they are used for data entry, whether we're logging into a website
or posting a blog comment. To build any interactive website, you'll need
to understand forms. Here we'll build a contact form for our tutorial
application.

A contact form is common on many websites. If you think about it,
contact forms are often unnecessary; simply displaying an email address
is sufficient, more convenient, and easier to implement. But building a
contact form is an excellent way to learn how to handle user data input.
We'll pretend that our odd client, Mr. Foobar Kadigan, insists that he
needs a contact form on his website.

We're not backing the tutorial application with a database so we won't
store the contact data after the information is submitted. Instead, in a
subsequent chapter we'll learn how to send the contents of the form by
email to the website owner.

The "Old Way" and the "Rails Way"
---------------------------------

In this chapter, we'll explore two ways to implement a contact form. The
first way will be familiar to anyone who has used PHP or similar web
platforms. It is an obvious and straightforward way to handle a form. As
we look closer, we'll see the approach has limitations. We'll discard
our first approach and rebuild the Contact page, discovering how the
"Rails way" is more powerful.

You may wonder why I'm going to show you two different ways to implement
the contact form.

First, it is worthwhile to see there is more than one way to implement a
web application. Maturity as a software developer means imagining
different approaches and evaluating your options. With this exercise,
you'll contrast two approaches and see how we make choices about
software architecture.

More importantly, it is not always obvious why we do things in a "Rails
way." It would be easy to simply walk you through the steps to build a
contact form without showing you alternative implementations (that's how
most tutorials do it). But you'll gain a deeper understanding of Rails
by building the contact form in a less sophisticated fashion and then
seeing the more elegant Rails approach.

User Story
----------

Let's plan our work with a user story:


```cucumber
*Contact Page*
As a visitor to the website
I want to fill out a form with my name, email address, and some text
In order to send a message to the owner of the website
```

Our first step will be to create a route to a controller that will
process the submitted form.

Routing
-------

We're going to create a ContactsController to process the submitted form
data. Every form must have a destination URL that receives the form
submission. We need to set a route to generate the destination URL.

Open the file **config/routes.rb**. Replace the contents with this:


```ruby
Rails.application.routes.draw do
  post 'contact', to: 'contacts#process_form'
  root to: 'visitors#new'
end
```

The route `post 'contact', to: 'contacts#process_form'` will create a
route helper that generates a URL and hands off the request to a
controller.

You can run the `rails routes` command to see our routes in the console:


```console
$ rails routes
 Prefix Verb URI Pattern        Controller#Action
contact POST /contact(.:format) contacts#process_form
   root GET  /                  visitors#new
   page GET  /pages/*id         high_voltage/pages#show
```

The output of the `rails routes` command is somewhat cryptic but confirms
we've created the routes we need.

The first item in the `rails routes` output indicates we can add
"contact" to "_path" to get our route helper, `contact_path`:

* `contact_path` - a route helper that can be used in a controller or
view

The second item indicates the request will be handled with the HTTP POST
protocol:

* `POST` - HTTP method to submit form data

The third item indicates the application will respond to the following
URL:

* [http://localhost:3000/contact](http://localhost:3000/contact) - URL
generated by the route helper

The fourth item indicates a request to the URL will be handled by:

* `contacts` - the name of the controller
* `process_form` - a controller action

For details about the syntax of routing directives, refer to
[RailsGuides: Routing from the Outside In](http://guides.rubyonrails.org/routing.html).

The route won't work yet; we need to create a ContactsController. But
first we'll create the form.

## Adding a Form to the Contact Page

Let's add the code for a contact form to the Contact page.

Forms were simple in the early days of the web. An HTML `<form>` tag creates a container for
a form. The form element specifies a URL (an "action") which receives and processes the form submission. Form fields accept input such as text or checkboxes. A submit button gathers the input and sends a request to the URL specified in the form action.

Rails tries to simplify forms and make them more powerful. First, to simplify forms, Rails provides a set of view helpers for forms. These view helpers automate the creation of the necessary HTML elements. Some developers use an alternative set of form helpers (such as the [SimpleForm gem](https://github.com/plataformatec/simple_form)) which make the syntax of forms even simpler. Form helpers such as SimpleForm add a dependency that I like to avoid (sometimes the gem is not updated or breaks). We'll use the standard Rails form helpers.

Rails also makes forms more powerful by providing a form builder that can be associated with a model. Associating a model with a form allows Rails to perform validation on the input data. We'll first build a form without a model (the "old way") and then add a model (the "Rails way").

Unfortunately, in the quest for simplicity and power, the Rails maintainers have made forms much more complicated than the original HTML specification. A large part of the complication is a new forms syntax introduced in Rails 5.1. Prior to Rails 5.1, Rails provided two different ways to create forms. One approach, using the `form_tag` directive, was simpler and didn't use a form builder and associated model. The second approach, using the `form_for` directive, was more powerful and widely used because it enabled validation of form data using an associated model. In Rails 5.1, the Rails maintainers introduced a third approach, using the `form_with` directive. The `form_with` approach replaces both the `form_tag` and `form_for` directives, combining both earlier approaches in one set of view helpers.

There is very little documentation to explain how to use the `form_with` approach. As of this writing, the [RailsGuides: Rails Form Helpers](http://guides.rubyonrails.org/form_helpers.html) official document has not been updated for the new `form_with` syntax. Most tutorials (and Stack Overflow answers) explain forms using the `form_tag` or `form_for` helpers. The only official documentation is the [Rails API document](http://api.rubyonrails.org/v5.1.2/classes/ActionView/Helpers/FormHelper.html#method-i-form_with). These are persuasive reasons not to use the new `form_with` syntax. However, a future version of Rails will deprecate (remove) the `form_tag` or `form_for` helpers. It's best to learn to use `form_with` for your forms. Our tutorial will use `form_with`.

Replace the contents of the file **app/views/pages/contact.html.erb**:

```erb
<% content_for :title do %>Contact<% end %>
<h3>Contact</h3>
<div class="form">
  <%= form_with(url: contact_path) do |form| %>
    <%= form.label :name %>
    <%= form.text_field :name, autofocus: true %>
    <br/>
    <br/>
    <%= form.label :email %>
    <%= form.email_field :email %>
    <br/>
    <br/>
    <%= form.label 'message' %>
    <%= form.text_area :content, size: '40x5' %>
    <br/>
    <br/>
    <%= form.submit 'Submit', class: 'submit' %>
  <% end %>
</div>
```

The code is compact but complex. We see several elements:

* `content_for` is a view helper that passes a page title to the
application layout

* `<div class="form">` sets the width of the form and applies any
styles we desire

* `form_with` is the view helper for the form

The `form_with` view helper instantiates a form builder object which we
assign to a variable named `form`. The form builder offers many standard form
elements, such as text fields and submit buttons. Each element is
available as a method call on the form object.

The view helper `form_with` requires *parameters* and a *block*.

Every form needs a URL that will handle
processing of the form data. In this case, we specify a route in the application:

* `url` - set to `contact_path`, the destination for the form data

Later, when we change this form to accommodate the"Rails way," we'll
replace these two parameters with a single instance variable. The magic
of Rails will generate the name of the form and the destination URL from
the instance variable. For now, to implement the "old way," we simply supply
the destination URL.

The `form_with` view helper accommodates a Ruby block. The block
begins with `do` and closes with `end`. The code inside the block works
just like code inside a method. In this case, the `form` object is
passed to the block and methods belonging to the `form` object are
called to produce HTML output.

Inside the block, the `form` object methods generate HTML for:

-   a name field
-   an email field
-   a content field (labeled "message")
-   a submit button

Each of the form methods takes various parameters, such as:

-   `autofocus` - displays the cursor in the field

The structure of the form is clearly visible in the code. The form
begins with a `form_with` helper and closes with the `end`
keyword. Each line of code produces an element in the form such as a
field or a button.

This is a common structure for a Rails view helper and it will soon
become familiar.

Controller
----------

We need code to process the form data. The form data is sent to the
server as a POST request attached to a URL. As we've learned, in Rails
we use controllers to respond to browser requests. For this
implementation, we'll create a ContactsController to process the
submitted form data.

Create a file **app/controllers/contacts_controller.rb**:


```ruby
class ContactsController < ApplicationController

  def process_form
    Rails.logger.debug "DEBUG: params are #{params.inspect}"
    flash[:notice] = "Received request from #{params[:name]}"
    redirect_to root_path
  end

end
```

The ContactsController inherits the behavior of the base
ApplicationController.

We create a `process_form` method to respond when the form is submitted.
Later we'll learn that `process_form` doesn't fit the "Rails way." We'll
use it for now.

Before we look closely at the code for the `process_form` method, we
need to learn about the `params` hash.

### Params Hash

Take a close look at these two lines:


```ruby
    Rails.logger.debug "DEBUG: params are #{params.inspect}"
    flash[:notice] = "Received request from #{params[:name]}"
```

Notice the `params` object.

Earlier we learned about the Ruby *Hash* class. It is a data structure
for key/value pairs and Hash instances are ideal for storing form data.
Each field on the form can be mapped as *label* and *data*, or key and
value, and stored in a Hash.

Rails does all the work of extracting the form data from the browser's
POST request. Rails creates a hash with the form field data mapped to
the form field labels. Here's part of the hash:


```ruby
{... "name"=>"Daniel", "email"=>"daniel@danielkehoe.com", "content"=>"hi" ...}
```

The full `params` hash actually contains more data which we can see with a debug command:

```ruby
{"utf8"=>"✓", "authenticity_token"=>"...", "name"=>"Daniel",
"email"=>"daniel@danielkehoe.com", "content"=>"hi", "commit"=>"Submit",
"controller"=>"contacts", "action"=>"process_form"}
```
The `params` hash includes these elements:

- the utf8 checkmark character forces browsers to recognize Unicode
- the authenticity token prevents CSRF ([Cross Site Request Forgery](https://en.wikipedia.org/wiki/Cross-site_request_forgery))
- form data
- current controller
- current action

You will see the contents of the `params` hash in the console log after
you submit the form. We'll look at the console log when we test the
implementation.

### Process_form Method

Now that we know about the `params` hash, take a look again at the
`process_form` method:


```ruby
  def process_form
    Rails.logger.debug "DEBUG: params are #{params.inspect}"
    flash[:notice] = "Received request from #{params[:name]}"
    redirect_to root_path
  end
```

We use a `logger.debug` method to reveal the form data in our console
log by revealing the contents of the `params` hash. The `inspect` method
shows the parameters in an easy-to-read list.

Then we extract the data posted to the name field of the form and
construct a flash message. A hash containing the data from the contact
form is nested inside the `params` hash. We can retrieve the value of
the name field with the expression `params[:name]`. We use
double quotes and string interpolation to form the message using the
`#{...}` syntax that evaluates a Ruby expression and combines it with a
string.

Finally we use the `redirect_to` directive to render the home page.

We haven't actually sent the contact data to anyone. We'll add code for
that later, after we refactor the controller to be a better example of
the "Rails way." Before we do that, let's test the current
implementation. We've already set up routing for the new controller.

Test the Application
--------------------

If you need to start the server:


```console
$ rails server
```

Open a web browser window and navigate to
[http://localhost:3000/](http://localhost:3000).

Click the "Contact" link; then fill out and submit the form.

You should see the flash message "Received request from …" on the home
page. If you see the message "My birthday is soon" you need to delete
your earlier experiment from the Visitors controller.

If you get an error message "uninitialized constant ContactsController,"
make sure you created the file **app/controllers/contacts_controller.rb** as instructed above.

Notice what appears in the console log:


```console
Started POST "/contact" for 127.0.0.1 at 2017-07-19 16:22:13 +0800
Processing by ContactsController#process_form as JS
  Parameters: {"utf8"=>"✓", "authenticity_token"=>"..", "name"=>"Daniel", "email"=>"daniel@danielkehoe.com", "content"=>"hi", "commit"=>"Submit"}
DEBUG: params are <ActionController::Parameters {"utf8"=>"✓", "authenticity_token"=>"...", "name"=>"Daniel", "email"=>"daniel@danielkehoe.com", "content"=>"hi", "commit"=>"Submit", "controller"=>"contacts", "action"=>"process_form"} permitted: false>
Redirected to http://localhost:3000/
Completed 200 OK in 7ms
```

The console log is our most important tool for debugging. Let's analyze
what we see:

-   *Started POST* - shows the server is responding to an HTTP POST request
-   *"/contact"* - the path portion of the URL
-   *at …* - timestamp
-   *Processing by ContactsController* - the controller
-   *process_form* - the controller action (the method that handles the request)
-   *as JS* - the standard syntax (not XML or some other markup)
-   *Parameters:* - the `params` hash containing all the submitted data
-   *"utf8"="✓"* - a Rails workaround to set the language encoding in Internet Explorer
-   *"authenticity token"* - prevents CSRF security exploits
-   the form data
-   *"commit"* - the "Submit" label from the button
-   *DEBUG* - our debug message containing the form data
-   *Redirected to http://localhost:3000/* - responded by displaying the home page
-   *Completed 200 OK* - HTTP response status code 200 indicating success
-   *in 7ms* - time required to process the request

That's a lot of data. For now, we really only care about the form data
buried in the `params` hash.

You can see that we really don't need the debug message because the
console log shows us the contents of the `params` hash.

The Validation Problem
----------------------

It looks like we've got everything we need to handle a form submission.
As a next step, we could implement code to send an email message using
form data extracted from the `params` hash.

But consider a potential problem. What if the email address is poorly
formed? The visitor will think the message has been sent but it will
never be delivered.

Or what if the name field or message is blank? It's not just a problem
for the hapless visitor. An evildoer could repeatedly click the submit
button, filling Foobar Kadigan's email inbox with endless empty
messages.

We need *validation* of the form data before we process it.

We could dig into the Rails `String` API and look for a way to test if
the string is empty or contains only whitespaces. And we could raise an
`Exception` if the string is blank.

Here's what validation code could look like. We won't use this code
(because there's a better way to do this):


```ruby
class ContactsController < ApplicationController

  def process_form
    if params[:name].blank?
      raise 'Name is blank!'
    end
    if params[:email].blank?
      raise 'Email is blank!'
    end
    if params[:content].blank?
      raise 'Message is blank!'
    end
    message = "Received request from #{params[:name]}"
    redirect_to root_path, :notice => message
  end

end
```

We would need additional code to test for invalid email addresses (it
will be a complex *regex*, or *regular expression*). And we would need a
nicer way of showing the error to the visitor (right now, raising the
exception displays an error message that makes it appear the application
is broken). If we were implementing this on another web application
platform, we might go further down this path, googling for code
examples, and implementing a lengthy but bulletproof validation
function.

Rails offers a better way.

Remove the Contact Page
-----------------------

We will implement a model-view-controller architecture for our Contact
feature. That means we need a Contact model, a Contacts controller, and
view files in the **app/views/contacts/** folder.

We no longer need the Contact page in the **app/views/pages/** folder.

Let's get started by removing the file
**app/views/pages/contact.html.erb**:


```console
$ rm app/views/pages/contact.html.erb
```

Before we implement a model-view-controller architecture, let's take
time to understand the advantages of the Rails model-view-controller
approach.

Implementing the "Rails Way"
----------------------------

Our initial implementation of the contact form is consistent with the
earliest approach to web application development. That's why I call it
the "old way." It is an approach that originated in 1993 with a
specification for CGI, the [Common Gateway
Interface](http://en.wikipedia.org/wiki/Common_Gateway_Interface).
Before CGI, every page on the web existed only as a static HTML file.
CGI made it possible to run a program, or CGI script, that dynamically
generated HTML. In the early years of the web, every web URL matched
either an HTML file or a CGI script. This is the "page paradigm" of the
web.

So far, we're following the "page paradigm." Our Contact page hosts the
form. Clicking the submit button makes a request to another page that is
actually a program that returns HTML. Until the late 1990s, this is how
the web worked. But soon after the introduction of CGI, developers began
exploring the possibility of running a single program (an application
server) that responds to any URL, parsing the URL to establish routing,
and generating pages dynamically. This was the genesis of the "web
application paradigm." It's how Rails works.

The web application paradigm frees us from one-to-one correspondence of
a URL with a single file or script. It allows us to refactor our code
into object-oriented classes and methods that can be inherited rather
than duplicated, which means we don't repeat the same code on every page
that processes a form.

The web application paradigm makes it possible to use the
model-view-controller architecture. Instead of looking at the web as
URLs that return pages, we see requests that are routed to controllers
that render views. We can segregate any code that manipulates data into
a model class, instead of mixing HTML with data manipulation in a single
script. With the "web application paradigm," we can have a generic model
class that isolates the code that connects to a database or validates
form data. We can create models that inherit the generic behavior from a
parent class and get a database connection or validation "for free."
Unlike the "page paradigm," we'll avoid duplicating validation code
every time we need to process a form.

Consider our `process_form` method again:


```ruby
class ContactsController < ApplicationController

  def process_form
    if params[:name].blank?
      raise 'Name is blank!'
    end
    if params[:email].blank?
      raise 'Email is blank!'
    end
    if params[:content].blank?
      raise 'Message is blank!'
    end
    message = "Received request from #{params[:name]}"
    redirect_to root_path, :notice => message
  end

end
```

We'll replace it with something better.

Our "segregation of concerns" philosophy suggests that validation belongs
in a model, since validation is a type of data manipulation (strictly
speaking, a test of data integrity). Furthermore, it would be nice to
make the validation tests generic so they could be used to validate data
submitted from any form.

Rails, as a framework, provides all this for us. We call it the "Rails
way."

ActiveModel
-----------

Rails extracts and generalizes common code that every website requires.
The code that websites need for access to databases is abstracted into
the Rails
[ActiveRecord](https://github.com/rails/rails/tree/master/activerecord)
class. ActiveRecord includes code from the
[ActiveModel](https://github.com/rails/rails/tree/master/activemodel)
class that handles interaction with forms and data validation.

The ActiveModel class interfaces with SimpleForm to provide
sophisticated validation and error handling. We can mix in behavior from
the ActiveModel class to add validation and error handling to any model
we create.

SimpleForm will recognize ActiveModel methods if we provide a model as
an argument to the SimpleForm view helper. SimpleForm will give the form
a name that matches the model name. And SimpleForm will automatically
generate a destination URL for the form based on the model name.

More significantly, SimpleForm will add sophisticated error handling to
the form. If a visitor doesn't enter a name or submits an invalid email
address, and we declare in our model that we require validation,
SimpleForm will highlight the invalid field and display an inline
message indicating the problem. Compared to what we've implemented so
far, this kind of error handling provides a vastly superior user
experience. Instead of displaying a message that the application failed,
the form will be redisplayed with the problem marked and noted.

Now that we've seen the advantages of the "Rails way," let's
re-implement our contact form using the model-view-controller
architecture.

Model
-----

When we build database-backed applications with Rails, we base our
models on a parent class named ActiveRecord. We are not using a database
for our tutorial application, so we'll mix in behavior from ActiveModel,
which adds validation and error handling to our model. Let's set up a
model that doesn't require a database.

Create a file **app/models/contact.rb**:


```ruby
class Contact
  include ActiveModel::Model
  attr_accessor :name, :email, :content

  validates_presence_of :name
  validates_presence_of :email
  validates_presence_of :content
  validates_format_of :email,
    with: /\A[-a-z0-9_+\.]+\@([-a-z0-9]+\.)+[a-z0-9]{2,4}\z/i
  validates_length_of :content, :maximum => 500

end
```

When you copy this, be careful to keep the long regex expression
(`with: /.../i`) on one line (no line breaks).

We give the model the name "Contact."

We mix in behavior from the ActiveModel class using
`include ActiveModel::Model`.

We create attributes (data fields) for the model by using the
`attr_accessor` keyword. The attributes match the fields in the contact form.
If we were using a database for our tutorial application, we would not need to
use `attr_accessor` because ActiveRecord would create access methods
for reading and writing attributes directly from the database.

ActiveModel gives us validation methods named `validates_presence_of`,
`validates_format_of`, and `validates_length_of`. We check that `name`,
`email`, and `content` exist (no blanks are allowed). We provide a
complex *regex*, or *regular expression*, to test if the email address
is valid. Finally, we declare that the message content cannot exceed 500
characters.

The model is elegant. We describe the fields we need and state our
validation requirements. ActiveModel does all the rest.

Next we'll add a new Contact page by creating a view in the
**app/views/contacts/** folder.

The new contact form will use our new model.

Create a New Contact Page
-------------------------

First, let's create the **app/views/contacts/** folder:


```console
$ mkdir app/views/contacts/
```

Create a file **app/views/contacts/new.html.erb**:


```erb
<% content_for :title do %>Contact<% end %>
<h3>Contact</h3>
<div class="form">
  <%= form_with(model: @contact) do |form| %>
    <%= form.label :name %>
    <%= form.text_field :name, autofocus: true %>
    <br/>
    <br/>
    <%= form.label :email %>
    <%= form.email_field :email %>
    <br/>
    <br/>
    <%= form.label 'message' %>
    <%= form.text_area :content, size: '40x5' %>
    <br/>
    <br/>
    <%= form.submit 'Submit', class: 'submit' %>
  <% end %>
</div>
```

The form is the same as we used before, but we're now providing only one
argument, the `@contact` instance variable, to the form_with view
helper. That's enough to generate the form name and destination URL.

We haven't yet created a controller that assigns the Contact model to
the `@contact` instance variable. We'll do that soon.

The form helper uses the `@contact` instance variable to name the form, set a
destination for the form data, and initialize each field in the form
using attributes from the Contact model. Setting the values for the form
fields from the attributes in the model is called "binding the form to
the object" and you can read about it in the [RailsGuides: Form
Helpers](http://guides.rubyonrails.org/form_helpers.html#binding-a-form-to-an-object)
article.

We've added the `error_notification` method which provides all the error
handling. The method call is very simple but the results will be
impressive.

We'll need a controller and routing to complete our
model-view-controller architecture. But first, we'll detour to learn
about seven standard controller actions.

Seven Controller Actions
------------------------

Consider all the possibilities for managing a list. It's a list of
anything: users, inventory, thingamajigs. We use a web application to
manage the list, so we'll fill out a form to record each item in our
list.

The web application offers seven features to help us manage our records:

-   ***index*** - display a list of all items
-   ***show*** - display a record of one item
-   ***new*** - display an empty form
-   ***create*** - save a record of a new item
-   ***edit*** - display a record for editing
-   ***update*** - save an edited record
-   ***destroy*** - delete a record

You can manage any list using these seven actions. There are a few extra
actions that are helpful, such as:

-   *pagination* - displaying a portion of a list
-   *sorting* - displaying the list in a different order
-   *bulk edit* - changing multiple items at once

But seven basic actions are all you need for managing any list of items.

The "Rails way" is about taking advantage of structure and convention to
leverage the power of the framework.

The ApplicationController contains code to implement each of the seven
standard actions. When we create a controller that inherits from the
ApplicationController, we get these standard actions "for free." That's
why our `new` method in our VisitorsController was so simple. The
controller knew to render a view file named **new.html.erb** from the
**views/visitors/** folder because of behavior inherited from the
ApplicationController.

Just like the Rails directory structure provides consistency to make it
easy for any Rails developer to collaborate with other Rails developers,
relying on the seven standard controller actions makes it easy for other
team members to understand how your controllers work.

A controller that uses these actions is said to be "RESTful" (a term
that refers to [representational state
transfer](http://en.wikipedia.org/wiki/Representational_state_transfer),
a software design abstraction). Experienced Rails developers follow the
"Rails way" and try to use RESTful controller methods when possible.

When necessary, you will add other controller actions. For example,
imagine you've built a subscription website. When a user's subscription
ends, you may not want to `destroy` the subscriber record. Instead you
might add a controller `expire` or `suspend` action that marks the
subscriber record as expired so you can continue to access the
subscriber's contact information for customer service or renewal offers.
To the extent you can, use the seven standard controller actions and be
cautious about adding more.

Earlier, I said our ContactsController `process_form` method isn't
suitable for the "Rails way." With our model-view-controller
architecture, we can piggyback on the ApplicationController to display
our empty contact form and process the form when it is submitted.

We'll use only two of the seven standard controller actions:

-   ***new*** - display the empty contact form
-   ***create*** - validate and process the submitted form

Our ContactsController will know to render a view from the
**app/views/contacts/new.html.erb** file when we call the controller
`new` method.

We won't piggyback on behavior from the ApplicationController `create`
method. But we'll implement a `create` method because, by convention,
the form will submit the data to the controller's `create` method.
SimpleForm will create a destination URL that corresponds to the
ContactsController#create action.

Controller
----------

Replace the contents of the file
**app/controllers/contacts_controller.rb**:


```ruby
class ContactsController < ApplicationController

  def new
    @contact = Contact.new
  end

  def create
    @contact = Contact.new(secure_params)
    if @contact.valid?
      # TODO send message
      flash[:notice] = "Message sent from #{@contact.name}."
      redirect_to root_path
    else
      render :new
    end
  end

  private

  def secure_params
    params.require(:contact).permit(:name, :email, :content)
  end

end
```

We've dropped the "old school" `process_form` method and added the
"Rails way" `new` and `create` methods.

The controller `new` action will instantiate an empty Contact model,
assign it to the `@contact` instance variable, and render the
**app/views/contacts/new.html.erb** view. We've already created the view
file containing the form.

SimpleForm will set a destination URL that corresponds to the
ContactsController#create action. The `create` method will instantiate
a new Contact model using the data from the form (we take steps to avoid
security vulnerabilities first—more on that later).

The ActiveModel class provides a method `valid?` which we can call on
the Contact model. Our conditional statement `if @contact.valid?` checks
each of the validation requirements we've set in the model.

If all the Contact fields are valid, we can send a message (which we'll add later),
prepare a flash message, and redirect to the home page.
Notice that we don't need to dig into the `params` hash for the
visitor's name; it is now available as `@contact.name` directly from the
model.

If any validation fails, the controller `create` action will render the
**app/views/contacts/new.html.erb** view. This time, appropriate error
messages are set and the form object's `error_notification` method will
highlight the invalid field and display a matching prompt.

You're looking at the tightly bound interaction of the "Rails way"
model, view, and controller.

The only element we are missing is routing. But first, let's look closer
at the steps we take to avoid security exploits.

### Mass-Assignment Vulnerabilities

Rails protects us from a class of security exploits called
"mass-assignment vulnerabilities." Rails won't let us initialize a model
with just any parameters submitted on a form. Suppose we were creating a
new user and one of the user attributes was a flag allowing
administrator access. A malicious hacker could create a fake form that
provides a user name and sets the administrator status to "true." Rails
forces us to "white list" each of the parameters used to initialize the
model.

We create a method named `secure_params` to screen the parameters sent
from the browser. The `params` hash contains two useful methods we use
for our screening:

-   `require(:contact)` - makes sure that `params[:contact]` is present
-   `permit(:name, :email, :content)` - our "white list"

With this code, we make sure that `params[:contact]` only contains
`:name, :email, :content`. If other parameters are present, they are
stripped out. Rails will raise an error if a controller attempts to pass
params to a model method without explicitly permitting attributes via
`permit`.

In older versions of Rails (before Rails 4.0), the mass-assignment
exploit was blocked by using a "white list" of acceptable parameters
with the `attr_accessible` keyword in a model. You'll see this code in
examples and tutorials that were written before Rails 4.0 introduced
"strong parameters" in the controller.

### Private Methods

If you paid close attention to the code you added to the Contacts
controller, you may have noticed the keyword `private` above the
`secure_params` method definition. This is a bit of software
architecture that limits access to the `secure_params` method (plus any
more methods we might add beneath it).

Very simply, adding the `private` keyword restricts access to the
`secure_params` method so only methods in the same class can use it. You
might be puzzled; after all, how else could it be accessed? We haven't
explored calling methods from other classes, so I'll just say that
without the `private` keyword, the `secure_params` method could be used
from code anywhere in our application. In this case, we apply the
`private` keyword because we want to be sure the `secure_params` method
is only used in the `ContactsController` class. It's just a bit of "best
practice" and for now, you can simply learn that `secure_params` method
should be a private method.

Now let's look at routing for controllers that are built the "Rails
way."

Routing
-------

Rails routing is aware of the seven standard controller actions.

In fact, it takes only one keyword (with one parameter) to generate
seven different routes for any controller.

The keyword is `resources` and supplying a name that matches a model and
controller provides all seven routes.

Open the file **config/routes.rb**. Replace the contents with this:


```ruby
Rails.application.routes.draw do
  resources :contacts, only: [:new, :create]
  root to: 'visitors#new'
end
```

Here we've added `resources :contacts, only: [:new, :create]`.

We only want two routes so we've added the restriction
`only: [:new, :create]`.

The `new` route has these properties:

-   `new_contact_path` - route helper
-   `contacts` - name of the controller (ContactsController)
-   `new` - controller action
-   [http://localhost:3000/contacts/new](http://localhost:3000/contacts/new) - URL generated by the route helper
-   `GET` - HTTP method to display a page

The `create` route has these properties:

-   `contacts_path` - route helper
-   `contacts` - name of the controller (ContactsController)
-   `create` - controller action
-   [http://localhost:3000/contacts](http://localhost:3000/contacts) - URL generated by the route helper
-   `POST` - HTTP method to submit form data

You can run the `rails routes` command to see these in the console:


```console
$ rails routes
     Prefix Verb URI Pattern             Controller#Action
   contacts POST /contacts(.:format)     contacts#create
new_contact GET  /contacts/new(.:format) contacts#new
       root GET  /                       visitors#new
       page GET  /pages/*id              high_voltage/pages#show
```

The output of the `rails
 routes` command shows we've created the routes
we need.

Our new route `new_contact_path` can now be used. We've completed our
move to the model-view-controller architecture by adding the appropriate
routes.

Change Navigation Links
-----------------------

With our new model-view-controller architecture, we need to change the
navigation links.

Change the file **app/views/layouts/_navigation_links.html.erb**:


```erb
<%# add navigation links to this file %>
<li><%= link_to 'About', page_path('about') %></li>
<li><%= link_to 'Contact', new_contact_path %></li>
```

We're ready to test the model-view-controller implementation of the
Contact feature.

Be sure you've removed the file **app/views/pages/contact.html.erb**, as
it is no longer used.

Test the Application
--------------------

If you need to restart the server:


```console
$ rails server
```

Open a web browser window and navigate to
[http://localhost:3000/](http://localhost:3000).

Click the "Contact" link; then fill out and submit the form.

You should see the flash message "Message sent from …" on the home page.

Try submitting the form with a blank name. You'll see a warning message,
"Please review the problems below."

Try submitting the form with an invalid email address such as "me@foo".
The form will re-display with a message, "Please review the problems
below," and next to the email field, "is invalid."

Combining SimpleForm error handling with ActiveModel validation is
powerful. If validation fails after the form is submitted, the page will
redisplay and SimpleForm will display an appropriate error message.

Git
---

Let's commit our changes to the Git repository and push to GitHub:


```console
$ git add -A
$ git commit -m "contact form"
$ git push
```

We've built a sophisticated Contact form.
